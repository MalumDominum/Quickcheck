# Quickcheck
У цьому завданні ви будете працювати з бібліотекою ScalaCheck для автоматизованого тестування на основі специфікації. 
Вам надається декілька реалізацій суто функціональної структури даних: heap, яка є пріоритетною чергою, що підтримує операції `insert`, `meld`, `findMin`, `deleteMin`. Ось інтерфейс:
```scala
trait Heap {
 type H // type of a heap
 type A // type of an element
 def ord: Ordering[A] // ordering on elements

 def empty: H // the empty heap
 def isEmpty(h: H): Boolean // whether the given heap h is empty

 def insert(x: A, h: H): H // the heap resulting from inserting x into h
 def meld(h1: H, h2: H): H // the heap resulting from merging h1 and h2

 def findMin(h: H): A // a minimum of the heap h
 def deleteMin(h: H): H // a heap resulting from deleting a minimum of h
}
```
Всі ці операції є чистими; вони ніколи не модифікують задані купи і можуть повертати нові купи. Цей суто функціональний інтерфейс взятий із статті Brodal & Okasaki, «Оптимальні чисто функціональні черги пріоритетів».
Черга з пріоритетом - це черга, в якій кожному елементу присвоюється "пріоритет". У класичних чергах елементи можуть бути отримані в порядку входження (додавання), тоді як у черзі з пріоритетами елементи отримуються відповідно до пріоритету, якому вони призначені. Таким чином, класичні черги - це просто черги пріоритетів, де пріоритетом є порядок вставки елементів.
Як видно з наведеного вище інтерфейсу, ми можемо створити чергу за допомогою
створення екземпляра порожньої черги.
вставки елемента в чергу (з прикріпленим пріоритетом), створюючи тим самим нову чергу.
додавання двох черг, що призводить до створення нової черги, яка містить усі елементи першої черги та всі елементи другої черги.
Крім того, ми можемо перевірити, чи черга порожня за допомогою isEmpty. Якщо черга не пуста, ви можете знайти її мінімум за допомогою findMin. Ви також можете отримати меншу чергу з непорожньої черги, видаливши мінімальний елемент за допомогою deleteMin. Купа оперує елементами Int, їх значення є пріоритетами, тому findMin знаходить найменше ціле число в купі.
Вам дано кілька реалізацій IntHeaps у файлі src / main / scala / quickcheck / Heap.scala. Лише одна з них є правильною, тоді як інші мають помилки. Ваша мета - написати деякі властивості, які будуть перевірені автоматично. Всі властивості, які ви пишете, повинні бути задоволені правильною реалізацією, тоді як принаймні одна з них повинна вийти з ладу в кожному неправильному виконанні, таким чином виявляючи помилку в реалізації. Зверніть увагу! Вам не потрібно виправляти помилки реалізації. Ваше завдання написати властивості, які виявлять недоліки. Тести до завдання написані таким чином, що перевіряють, що властивість істина на коректній реалізації купи і хибна на в іншому випадку.
Ви повинні написати свої властивості в тілі класу QuickCheckHeap у файлі src / main / scala / quickcheck / QuickCheck.scala.
## Генератор купи
Перш ніж перевіряти властивості, ми повинні спочатку створити кілька куп. Ваше перше завдання - реалізувати такий генератор:
`lazy val genHeap: Gen[H] = ???`

Ось кілька основних генераторів, які ви можете об’єднати, щоб створити більші:
* `arbitrary[T]`  - це генератор, який генерує довільне значення типу T. Оскільки нас цікавить IntHeaps, він буде генерувати довільні цілі числа, рівномірно розподілені.
* `oneOf (gen1, gen2)` - це генератор, який вибирає один із gen1 або gen2, рівномірно розподілено.
* `const (v)` - це генератор, який завжди повертає значення v.
Ви можете знайти набагато більше корисних  прикладів або в посібнику користувача ScalaCheck, або в Scaladocs

Наприклад, ми можемо написати генератор для типу Map [Int, Int] таким чином:
```scala
lazy val genMap: Gen[Map[Int,Int]] = oneOf(
 const(Map.empty[Int,Int]),
 for {
   k <- arbitrary[Int]
   v <- arbitrary[Int]
   m <- oneOf(const(Map.empty[Int,Int]), genMap)
 } yield m.updated(k, v)
)
```

## Написання властивостей
Тепер, коли у вас є генератор, ви можете писати тести на основі властивостей. Ідея тестування на основі властивостей полягає в тому, щоб перевірити, чи певні властивості зберігаються у ваших реалізаціях. Замість того, щоб точно вказати, яким вхідним даним повинні задовольняти наші властивості, ми натомість генеруємо випадкові вхідні дані та запускаємо кожен тест властивостей на цих випадково згенерованих даних. Таким чином ми збільшуємо ймовірність правильності нашої реалізації.
Наприклад, ми хотіли б перевірити, що додавання одного елемента до порожньої купи, а потім видалення цього елемента, має дати відповідний елемент. Ми б написали цю вимогу наступним чином:
```scala
property("min1") = forAll { a: Int =>
 val h = insert(a, empty)
 findMin(h) == a
}
```
Ще однією властивістю, яка нас може зацікавити, є те, що для будь-якої купи, якщо додати мінімальний елемент, а потім знайти його, то він і повернеться:
```scala
property("gen1") = forAll { (h: H) =>
 val m = if (isEmpty(h)) 0 else findMin(h)
 findMin(insert(m, h)) == m
}
```
У src / main / scala / quickcheck / QuickCheck.scala напишіть ще деякі властивості, які повинні бути задоволені. Ваші властивості повинні охоплювати принаймні такі відповідні факти:
* Якщо ви вставляєте будь-які два елементи в порожню купу, знаходження мінімуму результуючої купи повинно повернути найменший з двох елементів.
* Якщо ви вставляєте елемент у порожню купу, а потім видаляєте мінімальний елемент, то отримана купа повинна бути порожньою.
* Для будь-якої купи, ви повинні отримувати відсортовану послідовність елементів при постійному пошуку та видаленні мінімумів. (Підказка: рекурсія та допоміжні функції - ваші друзі.)
* Знаходження мінімуму злиття будь-яких двох куп повинно повернути мінімум першої або другої купи.

Зверніть увагу, що запропонованих властивостей недостатньо для перевірки. Дослідіть реалізацію куп та напишіть властивість, яка дозволяє виконати всі тести. Ви можете перевіряти додатково довільні властивості з використанням інтерфейсу купи, наприклад
* Додавання та видалення двох елементів до пустої купи повертає пусту купу
* Якщо додати елемент більше мінімального, мінімальний елемент купи має залишитися без змін
* Якщо поєднати дві черги, потім видалити мінімум першої, вставити в другу, поєднати і перевірити елементи черг, то вони мають бути однакові
* Список елементів поєднання черг має не залежати від порядку поєднання
* Якщо вставити елемент в купу, то вона буде його містити, навіть, якщо він не мінімальний
Не обмежуйтесь запропонованими властивостями. Можете проявити творчий підхід. 
Зверніть увагу, що іноді тести проходять при запуску з середовища розробки, але не проходять, якщо запустити їх з командного рядка sbt